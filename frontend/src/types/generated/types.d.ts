import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any
}

export type Category = {
  __typename?: 'Category'
  createdAt: Scalars['ISO8601DateTime']
  icon: Scalars['String']
  id: Scalars['Int']
  name: Scalars['String']
  nameEn: Scalars['String']
  questions: Array<Question>
  updatedAt: Scalars['ISO8601DateTime']
}

export type CategoryQuestionListPage = {
  __typename?: 'CategoryQuestionListPage'
  category: Category
  currentPage: Scalars['Int']
  lastPage: Scalars['Int']
  pageSize: Scalars['Int']
  questions: Array<Question>
}

export type Comment = {
  __typename?: 'Comment'
  content: Scalars['String']
  createdAt: Scalars['ISO8601DateTime']
  id: Scalars['Int']
  question: Question
  updatedAt: Scalars['ISO8601DateTime']
  user: User
}

/** Autogenerated input type of CreateLink */
export type CreateLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  description: Scalars['String']
  url: Scalars['String']
}

/** Autogenerated input type of CreateQuestion */
export type CreateQuestionInput = {
  categoryId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  content: Scalars['String']
  title: Scalars['String']
}

/** Autogenerated input type of CreateVote */
export type CreateVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  linkId?: InputMaybe<Scalars['ID']>
}

export type Email_Auth_Credentials = {
  email: Scalars['String']
  password: Scalars['String']
}

export type EmailAuthProviderSignUpData = {
  credentials?: InputMaybe<Email_Auth_Credentials>
}

export type Link = {
  __typename?: 'Link'
  description: Scalars['String']
  id: Scalars['ID']
  postedBy?: Maybe<User>
  url: Scalars['String']
  votes: Array<Vote>
}

export type LinkFilter = {
  OR?: InputMaybe<Array<LinkFilter>>
  descriptionContains?: InputMaybe<Scalars['String']>
  urlContains?: InputMaybe<Scalars['String']>
}

export type Mutation = {
  __typename?: 'Mutation'
  createLink?: Maybe<Link>
  createQuestion?: Maybe<Question>
  createVote?: Maybe<Vote>
  signInUser?: Maybe<SignInUserPayload>
  signUp?: Maybe<User>
}

export type MutationCreateLinkArgs = {
  input: CreateLinkInput
}

export type MutationCreateQuestionArgs = {
  input: CreateQuestionInput
}

export type MutationCreateVoteArgs = {
  input: CreateVoteInput
}

export type MutationSignInUserArgs = {
  input: SignInUserInput
}

export type MutationSignUpArgs = {
  input: SignUpInput
}

/** The query root of this schema */
export type Query = {
  __typename?: 'Query'
  allLinks: Array<Maybe<Link>>
  /** 全カテゴリを取得する */
  categories: Array<Category>
  /** 全カテゴリを各カテゴリ10件の質問と一緒に取得する */
  categoriesWithTenQuestions: Array<Category>
  /** Find a category by name_en */
  category: Category
  /** Get questions per category */
  categoryQuestions: CategoryQuestionListPage
  /** Find a question by ID */
  question: Question
  questions: Array<Question>
  /** Get questions per page */
  questionsPerPage: QuestionListPage
}

/** The query root of this schema */
export type QueryAllLinksArgs = {
  filter?: InputMaybe<LinkFilter>
  first?: InputMaybe<Scalars['Int']>
  skip?: InputMaybe<Scalars['Int']>
}

/** The query root of this schema */
export type QueryCategoryArgs = {
  nameEn: Scalars['String']
}

/** The query root of this schema */
export type QueryCategoryQuestionsArgs = {
  categoryId: Scalars['ID']
  page: Scalars['Int']
}

/** The query root of this schema */
export type QueryQuestionArgs = {
  id: Scalars['ID']
}

/** The query root of this schema */
export type QueryQuestionsPerPageArgs = {
  page: Scalars['Int']
}

export type Question = {
  __typename?: 'Question'
  comments: Array<Comment>
  content: Scalars['String']
  createdAt: Scalars['ISO8601DateTime']
  id: Scalars['Int']
  title: Scalars['String']
  updatedAt: Scalars['ISO8601DateTime']
  user: User
}

export type QuestionListPage = {
  __typename?: 'QuestionListPage'
  currentPage: Scalars['Int']
  lastPage: Scalars['Int']
  pageSize: Scalars['Int']
  questions: Array<Question>
}

/** Autogenerated input type of SignInUser */
export type SignInUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  credentials?: InputMaybe<Email_Auth_Credentials>
}

/** Autogenerated return type of SignInUser */
export type SignInUserPayload = {
  __typename?: 'SignInUserPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  token?: Maybe<Scalars['String']>
  user?: Maybe<User>
}

/** Autogenerated input type of SignUp */
export type SignUpInput = {
  authProvider?: InputMaybe<EmailAuthProviderSignUpData>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  name: Scalars['String']
}

export type User = {
  __typename?: 'User'
  createdAt: Scalars['ISO8601DateTime']
  email: Scalars['String']
  icon?: Maybe<Scalars['String']>
  id: Scalars['Int']
  links: Array<Link>
  name: Scalars['String']
  updatedAt: Scalars['ISO8601DateTime']
  votes: Array<Vote>
}

export type Vote = {
  __typename?: 'Vote'
  id: Scalars['ID']
  link: Link
  user: User
}

export type CreateLinkMutationVariables = Exact<{
  url: Scalars['String']
  description: Scalars['String']
}>

export type CreateLinkMutation = {
  __typename?: 'Mutation'
  createLink?: { __typename?: 'Link'; id: string; url: string } | null
}

export type CreateQuestionMutationVariables = Exact<{
  categoryId: Scalars['ID']
  title: Scalars['String']
  content: Scalars['String']
}>

export type CreateQuestionMutation = {
  __typename?: 'Mutation'
  createQuestion?: { __typename?: 'Question'; id: number; title: string } | null
}

export type SignInUserMutationVariables = Exact<{
  email: Scalars['String']
  password: Scalars['String']
}>

export type SignInUserMutation = {
  __typename?: 'Mutation'
  signInUser?: { __typename?: 'SignInUserPayload'; token?: string | null } | null
}

export type CategoriesQueryVariables = Exact<{ [key: string]: never }>

export type CategoriesQuery = {
  __typename?: 'Query'
  categories: Array<{ __typename?: 'Category'; id: number; name: string; nameEn: string }>
}

export type AllLinksQueryVariables = Exact<{ [key: string]: never }>

export type AllLinksQuery = {
  __typename?: 'Query'
  allLinks: Array<{ __typename?: 'Link'; votes: Array<{ __typename?: 'Vote'; id: string }> } | null>
}

export type QuestionsQueryVariables = Exact<{ [key: string]: never }>

export type QuestionsQuery = {
  __typename?: 'Query'
  questions: Array<{ __typename?: 'Question'; id: number; title: string; content: string }>
}

export type QuestionsPerPageQueryVariables = Exact<{
  page: Scalars['Int']
}>

export type QuestionsPerPageQuery = {
  __typename?: 'Query'
  questionsPerPage: {
    __typename?: 'QuestionListPage'
    currentPage: number
    lastPage: number
    pageSize: number
    questions: Array<{ __typename?: 'Question'; id: number; title: string }>
  }
}

export type CategoryQuestionsQueryVariables = Exact<{
  categoryId: Scalars['ID']
  page: Scalars['Int']
}>

export type CategoryQuestionsQuery = {
  __typename?: 'Query'
  categoryQuestions: {
    __typename?: 'CategoryQuestionListPage'
    currentPage: number
    lastPage: number
    pageSize: number
    category: { __typename?: 'Category'; id: number; name: string; nameEn: string }
    questions: Array<{ __typename?: 'Question'; id: number; title: string }>
  }
}

export const CreateLinkDocument = gql`
  mutation createLink($url: String!, $description: String!) {
    createLink(input: { url: $url, description: $description }) {
      id
      url
    }
  }
`
export type CreateLinkMutationFn = Apollo.MutationFunction<
  CreateLinkMutation,
  CreateLinkMutationVariables
>

/**
 * __useCreateLinkMutation__
 *
 * To run a mutation, you first call `useCreateLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLinkMutation, { data, loading, error }] = useCreateLinkMutation({
 *   variables: {
 *      url: // value for 'url'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useCreateLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateLinkMutation, CreateLinkMutationVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateLinkMutation, CreateLinkMutationVariables>(
    CreateLinkDocument,
    options,
  )
}
export type CreateLinkMutationHookResult = ReturnType<typeof useCreateLinkMutation>
export type CreateLinkMutationResult = Apollo.MutationResult<CreateLinkMutation>
export type CreateLinkMutationOptions = Apollo.BaseMutationOptions<
  CreateLinkMutation,
  CreateLinkMutationVariables
>
export const CreateQuestionDocument = gql`
  mutation createQuestion($categoryId: ID!, $title: String!, $content: String!) {
    createQuestion(input: { categoryId: $categoryId, title: $title, content: $content }) {
      id
      title
    }
  }
`
export type CreateQuestionMutationFn = Apollo.MutationFunction<
  CreateQuestionMutation,
  CreateQuestionMutationVariables
>

/**
 * __useCreateQuestionMutation__
 *
 * To run a mutation, you first call `useCreateQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQuestionMutation, { data, loading, error }] = useCreateQuestionMutation({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      title: // value for 'title'
 *      content: // value for 'content'
 *   },
 * });
 */
export function useCreateQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateQuestionMutation, CreateQuestionMutationVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateQuestionMutation, CreateQuestionMutationVariables>(
    CreateQuestionDocument,
    options,
  )
}
export type CreateQuestionMutationHookResult = ReturnType<typeof useCreateQuestionMutation>
export type CreateQuestionMutationResult = Apollo.MutationResult<CreateQuestionMutation>
export type CreateQuestionMutationOptions = Apollo.BaseMutationOptions<
  CreateQuestionMutation,
  CreateQuestionMutationVariables
>
export const SignInUserDocument = gql`
  mutation signInUser($email: String!, $password: String!) {
    signInUser(input: { credentials: { email: $email, password: $password } }) {
      token
    }
  }
`
export type SignInUserMutationFn = Apollo.MutationFunction<
  SignInUserMutation,
  SignInUserMutationVariables
>

/**
 * __useSignInUserMutation__
 *
 * To run a mutation, you first call `useSignInUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignInUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signInUserMutation, { data, loading, error }] = useSignInUserMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSignInUserMutation(
  baseOptions?: Apollo.MutationHookOptions<SignInUserMutation, SignInUserMutationVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<SignInUserMutation, SignInUserMutationVariables>(
    SignInUserDocument,
    options,
  )
}
export type SignInUserMutationHookResult = ReturnType<typeof useSignInUserMutation>
export type SignInUserMutationResult = Apollo.MutationResult<SignInUserMutation>
export type SignInUserMutationOptions = Apollo.BaseMutationOptions<
  SignInUserMutation,
  SignInUserMutationVariables
>
export const CategoriesDocument = gql`
  query categories {
    categories {
      id
      name
      nameEn
    }
  }
`

/**
 * __useCategoriesQuery__
 *
 * To run a query within a React component, call `useCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCategoriesQuery(
  baseOptions?: Apollo.QueryHookOptions<CategoriesQuery, CategoriesQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options)
}
export function useCategoriesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<CategoriesQuery, CategoriesQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options)
}
export type CategoriesQueryHookResult = ReturnType<typeof useCategoriesQuery>
export type CategoriesLazyQueryHookResult = ReturnType<typeof useCategoriesLazyQuery>
export type CategoriesQueryResult = Apollo.QueryResult<CategoriesQuery, CategoriesQueryVariables>
export const AllLinksDocument = gql`
  query allLinks {
    allLinks {
      votes {
        id
      }
    }
  }
`

/**
 * __useAllLinksQuery__
 *
 * To run a query within a React component, call `useAllLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllLinksQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllLinksQuery(
  baseOptions?: Apollo.QueryHookOptions<AllLinksQuery, AllLinksQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AllLinksQuery, AllLinksQueryVariables>(AllLinksDocument, options)
}
export function useAllLinksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<AllLinksQuery, AllLinksQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AllLinksQuery, AllLinksQueryVariables>(AllLinksDocument, options)
}
export type AllLinksQueryHookResult = ReturnType<typeof useAllLinksQuery>
export type AllLinksLazyQueryHookResult = ReturnType<typeof useAllLinksLazyQuery>
export type AllLinksQueryResult = Apollo.QueryResult<AllLinksQuery, AllLinksQueryVariables>
export const QuestionsDocument = gql`
  query questions {
    questions {
      id
      title
      content
    }
  }
`

/**
 * __useQuestionsQuery__
 *
 * To run a query within a React component, call `useQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<QuestionsQuery, QuestionsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options)
}
export function useQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QuestionsQuery, QuestionsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options)
}
export type QuestionsQueryHookResult = ReturnType<typeof useQuestionsQuery>
export type QuestionsLazyQueryHookResult = ReturnType<typeof useQuestionsLazyQuery>
export type QuestionsQueryResult = Apollo.QueryResult<QuestionsQuery, QuestionsQueryVariables>
export const QuestionsPerPageDocument = gql`
  query questionsPerPage($page: Int!) {
    questionsPerPage(page: $page) {
      questions {
        id
        title
      }
      currentPage
      lastPage
      pageSize
    }
  }
`

/**
 * __useQuestionsPerPageQuery__
 *
 * To run a query within a React component, call `useQuestionsPerPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionsPerPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionsPerPageQuery({
 *   variables: {
 *      page: // value for 'page'
 *   },
 * });
 */
export function useQuestionsPerPageQuery(
  baseOptions: Apollo.QueryHookOptions<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>(
    QuestionsPerPageDocument,
    options,
  )
}
export function useQuestionsPerPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>(
    QuestionsPerPageDocument,
    options,
  )
}
export type QuestionsPerPageQueryHookResult = ReturnType<typeof useQuestionsPerPageQuery>
export type QuestionsPerPageLazyQueryHookResult = ReturnType<typeof useQuestionsPerPageLazyQuery>
export type QuestionsPerPageQueryResult = Apollo.QueryResult<
  QuestionsPerPageQuery,
  QuestionsPerPageQueryVariables
>
export const CategoryQuestionsDocument = gql`
  query categoryQuestions($categoryId: ID!, $page: Int!) {
    categoryQuestions(categoryId: $categoryId, page: $page) {
      category {
        id
        name
        nameEn
      }
      questions {
        id
        title
      }
      currentPage
      lastPage
      pageSize
    }
  }
`

/**
 * __useCategoryQuestionsQuery__
 *
 * To run a query within a React component, call `useCategoryQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoryQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoryQuestionsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useCategoryQuestionsQuery(
  baseOptions: Apollo.QueryHookOptions<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>(
    CategoryQuestionsDocument,
    options,
  )
}
export function useCategoryQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    CategoryQuestionsQuery,
    CategoryQuestionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>(
    CategoryQuestionsDocument,
    options,
  )
}
export type CategoryQuestionsQueryHookResult = ReturnType<typeof useCategoryQuestionsQuery>
export type CategoryQuestionsLazyQueryHookResult = ReturnType<typeof useCategoryQuestionsLazyQuery>
export type CategoryQuestionsQueryResult = Apollo.QueryResult<
  CategoryQuestionsQuery,
  CategoryQuestionsQueryVariables
>
