import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ISO8601DateTime: { input: any; output: any; }
};

export type Category = {
  __typename?: 'Category';
  createdAt: Scalars['ISO8601DateTime']['output'];
  icon: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  nameEn: Scalars['String']['output'];
  questions: Array<Question>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CategoryQuestionListPage = {
  __typename?: 'CategoryQuestionListPage';
  category: Category;
  currentPage: Scalars['Int']['output'];
  lastPage: Scalars['Int']['output'];
  pageSize: Scalars['Int']['output'];
  questions: Array<Question>;
};

export type Comment = {
  __typename?: 'Comment';
  content: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['Int']['output'];
  question: Question;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

/** Autogenerated input type of CreateLink */
export type CreateLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

/** Autogenerated input type of CreateQuestion */
export type CreateQuestionInput = {
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateVote */
export type CreateVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  linkId?: InputMaybe<Scalars['ID']['input']>;
};

export type Email_Auth_Credentials = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type EmailAuthProviderSignUpData = {
  credentials?: InputMaybe<Email_Auth_Credentials>;
};

export type Link = {
  __typename?: 'Link';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  postedBy?: Maybe<User>;
  url: Scalars['String']['output'];
  votes: Array<Vote>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createLink?: Maybe<Link>;
  createQuestion?: Maybe<Question>;
  createVote?: Maybe<Vote>;
  signInUser?: Maybe<SignInUserPayload>;
  signUp?: Maybe<User>;
  updateQuestion?: Maybe<Question>;
};


export type MutationCreateLinkArgs = {
  input: CreateLinkInput;
};


export type MutationCreateQuestionArgs = {
  input: CreateQuestionInput;
};


export type MutationCreateVoteArgs = {
  input: CreateVoteInput;
};


export type MutationSignInUserArgs = {
  input: SignInUserInput;
};


export type MutationSignUpArgs = {
  input: SignUpInput;
};


export type MutationUpdateQuestionArgs = {
  input: UpdateQuestionInput;
};

/** The query root of this schema */
export type Query = {
  __typename?: 'Query';
  /** 全カテゴリを取得する */
  categories: Array<Category>;
  /** 全カテゴリを各カテゴリ10件の質問と一緒に取得する */
  categoriesWithTenQuestions: Array<Category>;
  /** Find a category by name_en */
  category: Category;
  /** Get questions per category */
  categoryQuestions: CategoryQuestionListPage;
  /** Find a question by ID */
  question: Question;
  questions: Array<Question>;
  /** Get questions per page */
  questionsPerPage: QuestionListPage;
};


/** The query root of this schema */
export type QueryCategoryArgs = {
  nameEn: Scalars['String']['input'];
};


/** The query root of this schema */
export type QueryCategoryQuestionsArgs = {
  categoryId: Scalars['ID']['input'];
  page: Scalars['Int']['input'];
};


/** The query root of this schema */
export type QueryQuestionArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of this schema */
export type QueryQuestionsPerPageArgs = {
  page: Scalars['Int']['input'];
};

export type Question = {
  __typename?: 'Question';
  category: Category;
  comments: Array<Comment>;
  content: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  postedByMe: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

export type QuestionListPage = {
  __typename?: 'QuestionListPage';
  currentPage: Scalars['Int']['output'];
  lastPage: Scalars['Int']['output'];
  pageSize: Scalars['Int']['output'];
  questions: Array<Question>;
};

/** Autogenerated input type of SignInUser */
export type SignInUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  credentials?: InputMaybe<Email_Auth_Credentials>;
};

/** Autogenerated return type of SignInUser. */
export type SignInUserPayload = {
  __typename?: 'SignInUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SignUp */
export type SignUpInput = {
  authProvider?: InputMaybe<EmailAuthProviderSignUpData>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** Autogenerated input type of UpdateQuestion */
export type UpdateQuestionInput = {
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  questionId: Scalars['ID']['input'];
  title: Scalars['String']['input'];
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  links: Array<Link>;
  name: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  votes: Array<Vote>;
};

export type Vote = {
  __typename?: 'Vote';
  id: Scalars['ID']['output'];
  link: Link;
  user: User;
};

export type CreateLinkMutationVariables = Exact<{
  url: Scalars['String']['input'];
  description: Scalars['String']['input'];
}>;


export type CreateLinkMutation = { __typename?: 'Mutation', createLink?: { __typename?: 'Link', id: string, url: string } | null };

export type CreateQuestionMutationVariables = Exact<{
  categoryId: Scalars['ID']['input'];
  title: Scalars['String']['input'];
  content: Scalars['String']['input'];
}>;


export type CreateQuestionMutation = { __typename?: 'Mutation', createQuestion?: { __typename?: 'Question', id: string, title: string } | null };

export type UpdateQuestionMutationVariables = Exact<{
  questionId: Scalars['ID']['input'];
  categoryId: Scalars['ID']['input'];
  title: Scalars['String']['input'];
  content: Scalars['String']['input'];
}>;


export type UpdateQuestionMutation = { __typename?: 'Mutation', updateQuestion?: { __typename?: 'Question', id: string, title: string, content: string, category: { __typename?: 'Category', id: number, name: string } } | null };

export type SignInUserMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignInUserMutation = { __typename?: 'Mutation', signInUser?: { __typename?: 'SignInUserPayload', token?: string | null, user?: { __typename?: 'User', id: number, name: string, email: string, icon?: string | null } | null } | null };

export type SignUpMutationVariables = Exact<{
  name: Scalars['String']['input'];
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignUpMutation = { __typename?: 'Mutation', signUp?: { __typename?: 'User', id: number, name: string, email: string, icon?: string | null } | null };

export type CategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type CategoriesQuery = { __typename?: 'Query', categories: Array<{ __typename?: 'Category', id: number, name: string, nameEn: string }> };

export type QuestionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type QuestionQuery = { __typename?: 'Query', question: { __typename?: 'Question', id: string, title: string, content: string, postedByMe: boolean, comments: Array<{ __typename?: 'Comment', id: number, content: string, user: { __typename?: 'User', id: number, name: string, icon?: string | null } }> } };

export type QuestionsQueryVariables = Exact<{ [key: string]: never; }>;


export type QuestionsQuery = { __typename?: 'Query', questions: Array<{ __typename?: 'Question', id: string, title: string, content: string }> };

export type QuestionsPerPageQueryVariables = Exact<{
  page: Scalars['Int']['input'];
}>;


export type QuestionsPerPageQuery = { __typename?: 'Query', questionsPerPage: { __typename?: 'QuestionListPage', currentPage: number, lastPage: number, pageSize: number, questions: Array<{ __typename?: 'Question', id: string, title: string, content: string }> } };

export type CategoryQuestionsQueryVariables = Exact<{
  categoryId: Scalars['ID']['input'];
  page: Scalars['Int']['input'];
}>;


export type CategoryQuestionsQuery = { __typename?: 'Query', categoryQuestions: { __typename?: 'CategoryQuestionListPage', currentPage: number, lastPage: number, pageSize: number, category: { __typename?: 'Category', id: number, name: string, nameEn: string }, questions: Array<{ __typename?: 'Question', id: string, title: string, content: string }> } };


export const CreateLinkDocument = gql`
    mutation createLink($url: String!, $description: String!) {
  createLink(input: {url: $url, description: $description}) {
    id
    url
  }
}
    `;
export type CreateLinkMutationFn = Apollo.MutationFunction<CreateLinkMutation, CreateLinkMutationVariables>;

/**
 * __useCreateLinkMutation__
 *
 * To run a mutation, you first call `useCreateLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLinkMutation, { data, loading, error }] = useCreateLinkMutation({
 *   variables: {
 *      url: // value for 'url'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useCreateLinkMutation(baseOptions?: Apollo.MutationHookOptions<CreateLinkMutation, CreateLinkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLinkMutation, CreateLinkMutationVariables>(CreateLinkDocument, options);
      }
export type CreateLinkMutationHookResult = ReturnType<typeof useCreateLinkMutation>;
export type CreateLinkMutationResult = Apollo.MutationResult<CreateLinkMutation>;
export type CreateLinkMutationOptions = Apollo.BaseMutationOptions<CreateLinkMutation, CreateLinkMutationVariables>;
export const CreateQuestionDocument = gql`
    mutation createQuestion($categoryId: ID!, $title: String!, $content: String!) {
  createQuestion(
    input: {categoryId: $categoryId, title: $title, content: $content}
  ) {
    id
    title
  }
}
    `;
export type CreateQuestionMutationFn = Apollo.MutationFunction<CreateQuestionMutation, CreateQuestionMutationVariables>;

/**
 * __useCreateQuestionMutation__
 *
 * To run a mutation, you first call `useCreateQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQuestionMutation, { data, loading, error }] = useCreateQuestionMutation({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      title: // value for 'title'
 *      content: // value for 'content'
 *   },
 * });
 */
export function useCreateQuestionMutation(baseOptions?: Apollo.MutationHookOptions<CreateQuestionMutation, CreateQuestionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateQuestionMutation, CreateQuestionMutationVariables>(CreateQuestionDocument, options);
      }
export type CreateQuestionMutationHookResult = ReturnType<typeof useCreateQuestionMutation>;
export type CreateQuestionMutationResult = Apollo.MutationResult<CreateQuestionMutation>;
export type CreateQuestionMutationOptions = Apollo.BaseMutationOptions<CreateQuestionMutation, CreateQuestionMutationVariables>;
export const UpdateQuestionDocument = gql`
    mutation updateQuestion($questionId: ID!, $categoryId: ID!, $title: String!, $content: String!) {
  updateQuestion(
    input: {questionId: $questionId, categoryId: $categoryId, title: $title, content: $content}
  ) {
    id
    category {
      id
      name
    }
    title
    content
  }
}
    `;
export type UpdateQuestionMutationFn = Apollo.MutationFunction<UpdateQuestionMutation, UpdateQuestionMutationVariables>;

/**
 * __useUpdateQuestionMutation__
 *
 * To run a mutation, you first call `useUpdateQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateQuestionMutation, { data, loading, error }] = useUpdateQuestionMutation({
 *   variables: {
 *      questionId: // value for 'questionId'
 *      categoryId: // value for 'categoryId'
 *      title: // value for 'title'
 *      content: // value for 'content'
 *   },
 * });
 */
export function useUpdateQuestionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQuestionMutation, UpdateQuestionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateQuestionMutation, UpdateQuestionMutationVariables>(UpdateQuestionDocument, options);
      }
export type UpdateQuestionMutationHookResult = ReturnType<typeof useUpdateQuestionMutation>;
export type UpdateQuestionMutationResult = Apollo.MutationResult<UpdateQuestionMutation>;
export type UpdateQuestionMutationOptions = Apollo.BaseMutationOptions<UpdateQuestionMutation, UpdateQuestionMutationVariables>;
export const SignInUserDocument = gql`
    mutation signInUser($email: String!, $password: String!) {
  signInUser(input: {credentials: {email: $email, password: $password}}) {
    token
    user {
      id
      name
      email
      icon
    }
  }
}
    `;
export type SignInUserMutationFn = Apollo.MutationFunction<SignInUserMutation, SignInUserMutationVariables>;

/**
 * __useSignInUserMutation__
 *
 * To run a mutation, you first call `useSignInUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignInUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signInUserMutation, { data, loading, error }] = useSignInUserMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSignInUserMutation(baseOptions?: Apollo.MutationHookOptions<SignInUserMutation, SignInUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignInUserMutation, SignInUserMutationVariables>(SignInUserDocument, options);
      }
export type SignInUserMutationHookResult = ReturnType<typeof useSignInUserMutation>;
export type SignInUserMutationResult = Apollo.MutationResult<SignInUserMutation>;
export type SignInUserMutationOptions = Apollo.BaseMutationOptions<SignInUserMutation, SignInUserMutationVariables>;
export const SignUpDocument = gql`
    mutation signUp($name: String!, $email: String!, $password: String!) {
  signUp(
    input: {name: $name, authProvider: {credentials: {email: $email, password: $password}}}
  ) {
    id
    name
    email
    icon
  }
}
    `;
export type SignUpMutationFn = Apollo.MutationFunction<SignUpMutation, SignUpMutationVariables>;

/**
 * __useSignUpMutation__
 *
 * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signUpMutation, { data, loading, error }] = useSignUpMutation({
 *   variables: {
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSignUpMutation(baseOptions?: Apollo.MutationHookOptions<SignUpMutation, SignUpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument, options);
      }
export type SignUpMutationHookResult = ReturnType<typeof useSignUpMutation>;
export type SignUpMutationResult = Apollo.MutationResult<SignUpMutation>;
export type SignUpMutationOptions = Apollo.BaseMutationOptions<SignUpMutation, SignUpMutationVariables>;
export const CategoriesDocument = gql`
    query categories {
  categories {
    id
    name
    nameEn
  }
}
    `;

/**
 * __useCategoriesQuery__
 *
 * To run a query within a React component, call `useCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<CategoriesQuery, CategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options);
      }
export function useCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CategoriesQuery, CategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options);
        }
export function useCategoriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CategoriesQuery, CategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options);
        }
export type CategoriesQueryHookResult = ReturnType<typeof useCategoriesQuery>;
export type CategoriesLazyQueryHookResult = ReturnType<typeof useCategoriesLazyQuery>;
export type CategoriesSuspenseQueryHookResult = ReturnType<typeof useCategoriesSuspenseQuery>;
export type CategoriesQueryResult = Apollo.QueryResult<CategoriesQuery, CategoriesQueryVariables>;
export const QuestionDocument = gql`
    query question($id: ID!) {
  question(id: $id) {
    id
    title
    content
    comments {
      id
      user {
        id
        name
        icon
      }
      content
    }
    postedByMe
  }
}
    `;

/**
 * __useQuestionQuery__
 *
 * To run a query within a React component, call `useQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useQuestionQuery(baseOptions: Apollo.QueryHookOptions<QuestionQuery, QuestionQueryVariables> & ({ variables: QuestionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QuestionQuery, QuestionQueryVariables>(QuestionDocument, options);
      }
export function useQuestionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuestionQuery, QuestionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QuestionQuery, QuestionQueryVariables>(QuestionDocument, options);
        }
export function useQuestionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<QuestionQuery, QuestionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QuestionQuery, QuestionQueryVariables>(QuestionDocument, options);
        }
export type QuestionQueryHookResult = ReturnType<typeof useQuestionQuery>;
export type QuestionLazyQueryHookResult = ReturnType<typeof useQuestionLazyQuery>;
export type QuestionSuspenseQueryHookResult = ReturnType<typeof useQuestionSuspenseQuery>;
export type QuestionQueryResult = Apollo.QueryResult<QuestionQuery, QuestionQueryVariables>;
export const QuestionsDocument = gql`
    query questions {
  questions {
    id
    title
    content
  }
}
    `;

/**
 * __useQuestionsQuery__
 *
 * To run a query within a React component, call `useQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
      }
export function useQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
        }
export function useQuestionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
        }
export type QuestionsQueryHookResult = ReturnType<typeof useQuestionsQuery>;
export type QuestionsLazyQueryHookResult = ReturnType<typeof useQuestionsLazyQuery>;
export type QuestionsSuspenseQueryHookResult = ReturnType<typeof useQuestionsSuspenseQuery>;
export type QuestionsQueryResult = Apollo.QueryResult<QuestionsQuery, QuestionsQueryVariables>;
export const QuestionsPerPageDocument = gql`
    query questionsPerPage($page: Int!) {
  questionsPerPage(page: $page) {
    questions {
      id
      title
      content
    }
    currentPage
    lastPage
    pageSize
  }
}
    `;

/**
 * __useQuestionsPerPageQuery__
 *
 * To run a query within a React component, call `useQuestionsPerPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionsPerPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionsPerPageQuery({
 *   variables: {
 *      page: // value for 'page'
 *   },
 * });
 */
export function useQuestionsPerPageQuery(baseOptions: Apollo.QueryHookOptions<QuestionsPerPageQuery, QuestionsPerPageQueryVariables> & ({ variables: QuestionsPerPageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>(QuestionsPerPageDocument, options);
      }
export function useQuestionsPerPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>(QuestionsPerPageDocument, options);
        }
export function useQuestionsPerPageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>(QuestionsPerPageDocument, options);
        }
export type QuestionsPerPageQueryHookResult = ReturnType<typeof useQuestionsPerPageQuery>;
export type QuestionsPerPageLazyQueryHookResult = ReturnType<typeof useQuestionsPerPageLazyQuery>;
export type QuestionsPerPageSuspenseQueryHookResult = ReturnType<typeof useQuestionsPerPageSuspenseQuery>;
export type QuestionsPerPageQueryResult = Apollo.QueryResult<QuestionsPerPageQuery, QuestionsPerPageQueryVariables>;
export const CategoryQuestionsDocument = gql`
    query categoryQuestions($categoryId: ID!, $page: Int!) {
  categoryQuestions(categoryId: $categoryId, page: $page) {
    category {
      id
      name
      nameEn
    }
    questions {
      id
      title
      content
    }
    currentPage
    lastPage
    pageSize
  }
}
    `;

/**
 * __useCategoryQuestionsQuery__
 *
 * To run a query within a React component, call `useCategoryQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoryQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoryQuestionsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useCategoryQuestionsQuery(baseOptions: Apollo.QueryHookOptions<CategoryQuestionsQuery, CategoryQuestionsQueryVariables> & ({ variables: CategoryQuestionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>(CategoryQuestionsDocument, options);
      }
export function useCategoryQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>(CategoryQuestionsDocument, options);
        }
export function useCategoryQuestionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>(CategoryQuestionsDocument, options);
        }
export type CategoryQuestionsQueryHookResult = ReturnType<typeof useCategoryQuestionsQuery>;
export type CategoryQuestionsLazyQueryHookResult = ReturnType<typeof useCategoryQuestionsLazyQuery>;
export type CategoryQuestionsSuspenseQueryHookResult = ReturnType<typeof useCategoryQuestionsSuspenseQuery>;
export type CategoryQuestionsQueryResult = Apollo.QueryResult<CategoryQuestionsQuery, CategoryQuestionsQueryVariables>;